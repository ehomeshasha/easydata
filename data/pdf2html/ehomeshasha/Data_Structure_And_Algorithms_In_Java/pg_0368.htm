<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0052)http://www.verypdf.com/ -->
<html>
<head>
<title>pg_0368</title>

<style>
<!-- 
select {font-size:12px;}
A:link {text-decoration: none; color: blue}
A:visited {text-decoration: none; color: purple}
A:active {text-decoration: red}
A:hover {text-decoration: underline; color:red}
-->
</style>
<script TYPE="text/javascript"> 
<!-- hide 
function killerrors()
{ 
return true; 
} 
window.onerror = killerrors; 
// --> 
</script>
<style type="text/css">
<!--
.ft0{font-style:normal;font-weight:normal;font-size:16px;font-family:Times New Roman;color:#000000;}
.ft1{font-style:normal;font-weight:normal;font-size:13px;font-family:Arial;color:#010100;}
.ft2{font-style:normal;font-weight:bold;font-size:16px;font-family:Arial;color:#010100;}
.ft3{font-style:normal;font-weight:bold;font-size:18px;font-family:Arial;color:#800000;}
.ft4{font-style:normal;font-weight:normal;font-size:13px;font-family:Arial;color:#008000;}
.ft5{font-style:normal;font-weight:normal;font-size:13px;font-family:Arial;color:#000000;}
-->
</style>
</head>
<body vlink="#FFFFFF" link="#FFFFFF" bgcolor="#ffffff">

<script TYPE="text/javascript">
var currentpos,timer; 
function initialize() 
{ 
timer=setInterval("scrollwindow()",10);
} 
function sc(){
clearInterval(timer); 
}
function scrollwindow() 
{ 
currentpos=document.body.scrollTop; 
window.scroll(0,++currentpos); 
if (currentpos != document.body.scrollTop) 
sc();
} 
document.onmousedown=sc
document.ondblclick=initialize
</script>
<div style="position:absolute;top:0;left:0"><img width="826" height="1169" src="pg_0368.jpg" ALT=""></div>
<div style="position:absolute;top:1102;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:1102;left:391"><span class="ft0"> - 368 -</span></div>
<div style="position:absolute;top:81;left:90"><span class="ft1">appended, and the block is written back out. This involves only two file accesses.</span></div>
<div style="position:absolute;top:78;left:587"><span class="ft0"> </span></div>
<div style="position:absolute;top:81;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:100;left:80"><span class="ft0"> </span></div>
<div style="position:absolute;top:115;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:115;left:90"><span class="ft2"> Multiple Indexes</span></div>
<div style="position:absolute;top:115;left:220"><span class="ft0"> </span></div>
<div style="position:absolute;top:115;left:640"><span class="ft0">  </span></div>
<div style="position:absolute;top:119;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:138;left:80"><span class="ft0"> </span></div>
<div style="position:absolute;top:192;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:154;left:90"><span class="ft1"> An advantage of the indexed approach is that multiple indexes, each with a different key, </span></div>
<div style="position:absolute;top:170;left:90"><span class="ft1">can be created for the same file. In one index the keys can be last names, in another </span></div>
<div style="position:absolute;top:186;left:90"><span class="ft1">telephone numbers, in another addresses. Because the indexes are small compared with </span></div>
<div style="position:absolute;top:202;left:90"><span class="ft1">the file, this doesn't increase the total data storage very much. Of course, it does present </span></div>
<div style="position:absolute;top:218;left:90"><span class="ft1">more of a challenge when items are deleted from the file, because entries must be </span></div>
<div style="position:absolute;top:234;left:90"><span class="ft1">deleted from all the indexes, but we won't get into that here.</span></div>
<div style="position:absolute;top:231;left:457"><span class="ft0"> </span></div>
<div style="position:absolute;top:192;left:640"><span class="ft0">  </span></div>
<div style="position:absolute;top:234;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:253;left:80"><span class="ft0"> </span></div>
<div style="position:absolute;top:268;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:269;left:90"><span class="ft2"> Index Too Large for Memory</span></div>
<div style="position:absolute;top:269;left:314"><span class="ft0"> </span></div>
<div style="position:absolute;top:268;left:640"><span class="ft0">  </span></div>
<div style="position:absolute;top:272;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:291;left:80"><span class="ft0"> </span></div>
<div style="position:absolute;top:321;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:307;left:90"><span class="ft1"> If the index is too large to fit in memory, it must be broken into blocks and stored on the </span></div>
<div style="position:absolute;top:323;left:90"><span class="ft1">disk. For large files it may then be profitable to store the index itself as a B-tree. In the </span></div>
<div style="position:absolute;top:339;left:90"><span class="ft1">main file the records are stored in any convenient order.</span></div>
<div style="position:absolute;top:336;left:434"><span class="ft0"> </span></div>
<div style="position:absolute;top:321;left:640"><span class="ft0">  </span></div>
<div style="position:absolute;top:339;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:358;left:80"><span class="ft0"> </span></div>
<div style="position:absolute;top:388;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:374;left:90"><span class="ft1"> This arrangement can be very efficient. Appending records to the end of the main file is a </span></div>
<div style="position:absolute;top:390;left:90"><span class="ft1">fast operation, and the index entry for the new record is also quick to insert because the </span></div>
<div style="position:absolute;top:406;left:90"><span class="ft1">index is a tree. The result is very fast searching and insertion for large files.</span></div>
<div style="position:absolute;top:403;left:551"><span class="ft0"> </span></div>
<div style="position:absolute;top:388;left:640"><span class="ft0">  </span></div>
<div style="position:absolute;top:406;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:426;left:80"><span class="ft0"> </span></div>
<div style="position:absolute;top:463;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:441;left:90"><span class="ft1"> Note that when an index is arranged as a B-tree, each node contains a number of child </span></div>
<div style="position:absolute;top:457;left:90"><span class="ft1">pointers and one fewer data items. The child pointers are the block numbers of other </span></div>
<div style="position:absolute;top:473;left:90"><span class="ft1">nodes in the index. The data items consist of a key value and a pointer to a block in the </span></div>
<div style="position:absolute;top:489;left:90"><span class="ft1">main file. Don't confuse these two kinds of block pointers.</span></div>
<div style="position:absolute;top:486;left:443"><span class="ft0"> </span></div>
<div style="position:absolute;top:463;left:640"><span class="ft0">  </span></div>
<div style="position:absolute;top:490;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:509;left:80"><span class="ft0"> </span></div>
<div style="position:absolute;top:525;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:524;left:90"><span class="ft3"> Complex Search Criteria</span></div>
<div style="position:absolute;top:526;left:308"><span class="ft0"> </span></div>
<div style="position:absolute;top:525;left:640"><span class="ft0">  </span></div>
<div style="position:absolute;top:530;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:549;left:80"><span class="ft0"> </span></div>
<div style="position:absolute;top:595;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:565;left:90"><span class="ft1"> In complex searches the only practical approach may be to read every block in a file </span></div>
<div style="position:absolute;top:581;left:90"><span class="ft1">sequentially. Suppose in our phone book example we wanted a list of all entries in the </span></div>
<div style="position:absolute;top:597;left:90"><span class="ft1">phone book with first name Frank, who lived in Springfield, and who had a phone number </span></div>
<div style="position:absolute;top:613;left:90"><span class="ft1">with three &quot;7&quot; digits in it. (These were perhaps clues found scrawled on a scrap of paper </span></div>
<div style="position:absolute;top:629;left:90"><span class="ft1">clutched in the hand of a victim of foul play.)</span></div>
<div style="position:absolute;top:626;left:361"><span class="ft0"> </span></div>
<div style="position:absolute;top:595;left:640"><span class="ft0">  </span></div>
<div style="position:absolute;top:629;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:648;left:80"><span class="ft0"> </span></div>
<div style="position:absolute;top:694;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:664;left:90"><span class="ft1"> A file organized by last names would be no help at all. Even if there were index files </span></div>
<div style="position:absolute;top:680;left:90"><span class="ft1">ordered by first names and cities, there would be no convenient way to find which files </span></div>
<div style="position:absolute;top:696;left:90"><span class="ft1">contained both Frank and Springfield. In such cases (which are quite common in many </span></div>
<div style="position:absolute;top:712;left:90"><span class="ft1">kinds of databases) the fastest approach is probably to read the file sequentially, block by </span></div>
<div style="position:absolute;top:728;left:90"><span class="ft1">block, checking each record to see if it meets the criteria.</span></div>
<div style="position:absolute;top:725;left:440"><span class="ft0"> </span></div>
<div style="position:absolute;top:694;left:640"><span class="ft0">  </span></div>
<div style="position:absolute;top:728;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:747;left:80"><span class="ft0"> </span></div>
<div style="position:absolute;top:764;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:763;left:90"><span class="ft3"> Sorting External Files</span></div>
<div style="position:absolute;top:765;left:283"><span class="ft0"> </span></div>
<div style="position:absolute;top:764;left:640"><span class="ft0">  </span></div>
<div style="position:absolute;top:769;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:788;left:80"><span class="ft0"> </span></div>
<div style="position:absolute;top:818;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:804;left:90"><span class="ft1"> Mergesort is the preferred algorithm for sorting external data. This is because, more so </span></div>
<div style="position:absolute;top:820;left:90"><span class="ft1">than most sorting techniques, disk accesses tend to occur in adjacent records rather than </span></div>
<div style="position:absolute;top:836;left:90"><span class="ft1">random parts of the file.</span></div>
<div style="position:absolute;top:833;left:236"><span class="ft0"> </span></div>
<div style="position:absolute;top:818;left:640"><span class="ft0">  </span></div>
<div style="position:absolute;top:836;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:855;left:80"><span class="ft0"> </span></div>
<div style="position:absolute;top:901;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:871;left:90"><span class="ft1"> Recall from</span></div>
<div style="position:absolute;top:871;left:161"><span class="ft4"> Chapter 6, &quot;Recursion,&quot;</span></div>
<div style="position:absolute;top:871;left:309"><span class="ft5"> that mergesort works recursively by calling itself to </span></div>
<div style="position:absolute;top:887;left:90"><span class="ft5">sort smaller and smaller sequences. Once two of the smallest sequences (one byte each </span></div>
<div style="position:absolute;top:903;left:90"><span class="ft5">in the internal-memory version) have been sorted, they are then merged into a sorted </span></div>
<div style="position:absolute;top:919;left:90"><span class="ft5">sequence twice as long. Larger and larger sequences are merged, until eventually the </span></div>
<div style="position:absolute;top:935;left:90"><span class="ft5">entire file is sorted.</span></div>
<div style="position:absolute;top:932;left:207"><span class="ft0"> </span></div>
<div style="position:absolute;top:901;left:640"><span class="ft0">  </span></div>
<div style="position:absolute;top:935;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:954;left:80"><span class="ft0"> </span></div>
<div style="position:absolute;top:976;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:970;left:90"><span class="ft1"> The approach for external storage is similar. However, the smallest sequence that can be </span></div>
<div style="position:absolute;top:986;left:90"><span class="ft1">read from the disk is a block of records. Thus, a two-stage process is necessary.</span></div>
<div style="position:absolute;top:983;left:584"><span class="ft0"> </span></div>
<div style="position:absolute;top:976;left:640"><span class="ft0">  </span></div>
<div style="position:absolute;top:986;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:1005;left:80"><span class="ft0"> </span></div>
<div style="position:absolute;top:1035;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:1021;left:90"><span class="ft1"> In the first phase, a block is read, its records are sorted internally, and the resulting </span></div>
<div style="position:absolute;top:1037;left:90"><span class="ft1">sorted block is written back to disk. The next block is similarly sorted and written back to </span></div>
<div style="position:absolute;top:1053;left:90"><span class="ft1">disk. This continues until all the blocks are internally sorted.</span></div>
<div style="position:absolute;top:1050;left:455"><span class="ft0"> </span></div>
<div style="position:absolute;top:1035;left:640"><span class="ft0">  </span></div>
<div style="position:absolute;top:1053;left:79"><span class="ft0"> </span></div>
<div style="position:absolute;top:1072;left:80"><span class="ft0"> </span></div>
<script TYPE="text/javascript">
			var currentZoom = parent.ltop.currentZoom;
			if(currentZoom != undefined)
				document.body.style.zoom=currentZoom/100;
			</script>
</body>
</html>